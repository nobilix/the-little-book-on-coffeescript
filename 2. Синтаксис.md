Перед тем, как прямиком перейти к основной теме этого раздела, я бы хотел повторить: несмотря на то, что синтаксис CoffeeScript похож на синтаксис JavaScript, CoffeeScript не является подмножеством JavaScript. Поэтому нельзя писать JS-конструкции в CoffeeScript-файле, так как при компиляции компилятор выдаст ошибку. Если вы пишете код на CoffeeScript — то он должен быть написан на чистом CoffeeScript. Не надо смешивать два разных языка.

Почему CoffeeScript не является подмножеством? Потому что CoffeeScript уделяет весьма значительное внимание чистоте и лаконичности кода. В CoffeeScript многие ключевые слова из JavaScript были убраны, благодаря чему сократилось количество ошибок и кода.

Кстати, я нахожу весьма странным то, что компилятор CoffeeScript написан на CoffeeScript! Похоже, что на вопрос «что было раньше — курица или яйцо»  наконец-то найден ответ!

Итак, давайте рассмотрим основы. В CoffeeScript нет нужды добавлять точку с запятой в конце строки — компилятор автоматически её добавит при компиляции. Точки с запятой являются причиной многочисленных дискуссий в JavaScript сообществе, в частности, из-за странного поведения интерпретатора при их обработке. Слава богу, CoffeeScript решает эту проблему просто убрав точки с запятой из своего синтаксиса.

Комментарии форматируются так же, как и в языке Ruby, начинаясь со знака `#`.

```coffeescript
# A comment
```

Мультистрочные комментарии также поддерживаются. Они начинаются и заканчиваются тремя символами `#`.

```coffeescript
###
   Комментарий, который занимает
   несколько строк.
###
```

Как я уже упомянул ранее, CoffeeScript весьма лаконичен. На практике это означает к примеру то, что вы можете заменить фигурные скобки ({}) tab'ом. Эта фича вдохновлена языком Python. Есть и недостатки — придётся внимательно следить за форматированием кода.

## Переменные и область видимости
CoffeeScript устраняет одну из основных проблем JavaScript — глобальные переменные. В JavaScript весьма легко объявить глобальную переменную, забыв добавить ключевое слово `var` перед её именем. CoffeeScript решает эту проблему убирая глобальные переменные. После компиляции CoffeeScript оборачивает весь наш код в анонимную функцию, тем самым разделяя глобальную и локальную области видимости. Рассмотрим в качестве примера простое объявление переменной и присваивание ей значения:

```coffeescript
myVariable = "test"
```

Скомпилированный JS-код:

```javascript
var myVariable;
myVariable = "test";
```

Как вы можете видеть, в этом коде совершается присвоение локальной переменной. CoffeeScript делает шаг вперёд и предотвращает довольно распространённую ошибку JavaScript-разработчиков.

Однако иногда бывает полезно создать глобальную переменную. Вы можете сделать переменную свойством глобального объекта (в браузерах — window), либо с помощью следующего способа:

```coffeescript
exports = this
exports.MyVariable = "foo-bar"
```

В корневом контексте this является глобальным объектом,и путём создания переменной exports вы делаете более понятным то, какие глобальные переменные задаются в вашем скрипте. Кроме того, такой способ позволяет использовать модули CommonJS, которые мы рассмотрим несколько позже.

## Функции
CoffeeScript сокращает довольно крупное объявление функции небольшой стрелкой: ->. Функции могут помещаться в одну строку или быть мультистрочными. Последнее выражение в функции неявно возвращается. Иначе говоря, вам не нужно использовать ключевое слово return, если вы захотите, чтобы функция возвращала что-либо — просто поместите это что-либо в конце.

Давайте рассмотрим такой пример:

```coffeescript
func = -> "bar"
```

Скомпилированный вариант:

```javascript
var func;
func = function() {
  return "bar";
};
```

Как вы можете видеть, стрелка (->) скомпилировалось в выражение function, а перед строкой "bar" автоматически добавилось ключевое слово return.

Я уже говорил ранее, что нет причин не использовать мультистрочные функции — главное, чтобы отступы были корректны.

```coffeescript
func = ->
  # An extra line
  "bar"
```

### Аргументы функций
Как быть с аргументами функций? Что же, CoffeeScript предоставляет возможность объявить аргументы в скобках перед стрелокой.

```coffeescript
times = (a, b) -> a * b
```

CoffeeScript также поддерживает задание значений аргументов по умолчанию, например:

```coffeescript
times = (a = 1, b = 2) -> a * b
```

Также вы можете использовать три точки (...), чтобы указать на то, что в функцию может быть передано несколько аргументов:

```coffeescript
sum = (nums...) -> 
  result = 0
  nums.forEach (n) -> result += n
  result
```

В примере выше перменная nums является массивом со всеми переданными аргументами. Это не объект, а именно массив, так что вам не придётся беспокоиться об использовании `Array.prototype.splice` или `jQuery.makeArray()`.

```coffeescript
trigger = (events...) ->
  events.splice(1, 0, this)
  this.constructor.trigger.apply(events)
```

### Вызов функций
В CoffeeScript функции могут быть вызваны так же, как и в JavaScript: со скобками () или с помощью apply() / call(). Также функции могут быть вызваны без скобок, как в Ruby или Python:

```coffeescript
a = "Howdy!"

alert a
# Аналог:
alert(a)

alert inspect a
# Аналог:
alert(inspect(a))
```

Я рекомендую использовать скобки в тех случаях, когда не совсем очевидно, что вызывается и с какими аргументами. Например, в последней строчке примера я бы определенно поставил скобки.

```coffeescript
alert inspect(a)
```

Отмечу, что если вы хотите вызвать функцию без аргументов, то CoffeeScript не сможет определить, намерены вы вызвать функцию или присвоить значение переменной. В этом плане поведение CoffeeScript несколько отличается от Ruby, в котором в таких случаях будет вызвана функция. Такое поведение также несколько схоже с поведением в Python. Эта тонкость была причиной нескольких ошибок в моих CoffeeScript-программах, поэтому внимательно отслеживайте случаи вызова функций без аргументов и добавляйте к ним круглые скобки.

### Контекст функции
В JavaScript часто изменяется контекст выполнения функции, особенно при работе с коллбэками событий. Поэтому CoffeeScript предоставляет инструменты для предотвращения ошибок при работе с контекстом. Одним из таких инструментов является «жирная» стрелка: `=>`.

Использование «жирной» стрелки гарантирует, что контекст исполнения функции будет привязан к локальному. Например:

```coffeescript
this.clickHandler = -> alert "clicked"
element.addEventListener "click", (e) => this.clickHandler(e)
```

Причина по которой вы можете воспользоваться таким способом — то, что коллбэк из `addEventListener` будет выполнен в контексте элемента, то есть `this` будет являться элементом. Если вы хотите использовать локальный контекст без костылей вида `self = this`, «жирная» стрелка — это то, что вам нужно.

Эта идея привязки аналогична методу `proxy()` из jQuery или методу `bind()` из ES5.
